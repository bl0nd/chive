#!/usr/bin/env bash
#
# chive - File variant switcher

PROG_NAME="chive"
VERSION="0.1.0"

XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-${HOME}/.config}
CONFIG_DIR="${XDG_CONFIG_HOME}/${PROG_NAME}"

# Speed up script by not using unicode.
LC_ALL=C
LANG=C


# Print out help message and exit
usage() {
    printf '%s\n' "\
usage: chive [--version] [--help] [-e | --edit] [-l | --list] [-c | --check]
             [-t | --target <target> ...] [-v | --variant <target> | <variant> ...]
             [-d | --delete <target> | <variant>] [[<target> ...] <variant>] ...

Options:

   -t, -target TARGET ...     add targets
   -v, --variant VARIANT ...  add variants
   -e, --edit VARIANT ...     edit variants
   -l, --list VARIANT ...     list variants
   -c, --check VARIANT ...    check variants

   --help                     show version information of $PROG_NAME
   --version                  show this help and exit
"
    exit 1
}


# Exit with an error
die() {
    printf 'error: %s\n' "$1" 1>&2
    exit 1
}


# Colors the contents of its STDIN like so:
#
#  * Line characters: white
#  * All other characters: blue
#
# This is typically used for the `tree` command, but is also used for `ls` to
# color the filenames.
color_listing() {
    GREP_COLORS='sl=1;30:ms=01;34' grep --color '[^├─│└─]'
}


# Outputs the final component of a file path passed to its STDIN
pathname() {
    awk -F/ '{print $NF}'
}


# Does a general check on target and variant names
check_name() {
    if [[ ! "$1" =~ ^[[:alnum:]](.*) ]]; then
        die "targets and variants may only contain letters, numbers, \"_\", or \"-\""
    elif [[ ! "$1" =~ ^([[:alnum:]]+[_-]*)*$ ]]; then
        die "targets and variants must start with a letter or number"
    fi
}

# Outputs the "content" section of variants. To get the content, we:
#
#  1. Skip header (i.e., first line).
#  2. Delete leading and trailing blank lines.
v_body() {
    tail -n +2 "$1" | tac | sed '/./,$!d' | tac | sed '/./,$!d'
}


# Add target files
t_add() {
    local targets=() new_targets=()
    local i name
    local line t_paths=()
    local pattern
    local path

    # Exit if no targets are specified
    (( "$#" == 0 )) && die "no targets specified"

    # Read arguments into array
    IFS=' ' read -r -a targets <<< "$@"

    # Store STDIN data, if any
    if ! test -t 0; then
        while read -r line; do
            t_paths+=("$line")
        done
    fi

    # Add targets
    for i in "${!targets[@]}"; do
        name="${targets[i]}"

        # Check names to see if they're valid target names
        check_name "$name"

        if grep -m 1 -q ^"$name"$ <<< "$ALL_VARIANTS"; then
            die "\"$name\" is an existing variant"
        fi

        # Create target directory and config file
        mkdir -p "$CONFIG_DIR/$name"
        touch "$CONFIG_DIR/$name/.config"

        # Handle custom target paths
        if (( "${#t_paths[@]}" > 0 )); then
            # If there are more targets than paths, use the last path for any
            # remaining targets
            (( "$i" < "${#t_paths[@]}" )) && path="${t_paths[i]}"
            printf '%s\n' "$path" > "$CONFIG_DIR/$name/.config"
        fi

        new_targets+=("$name")
    done

    # Show all targets
    if (( "${#new_targets[@]}" == 0 )); then
        # No new targets were added, so just list all targets in the same color
        # TODO: List specified targets in yellow or something
        (cd "$CONFIG_DIR" && ls -1 -d -- */ | sed 's/.$//' | color_listing)
    else
        # New targets were found, so highlight the new targets
        pattern="$(sed 's/ /|/g' <<< "${new_targets[@]}" | xargs printf '^(%s)$')"
        (cd "$CONFIG_DIR" && ls -1 | GREP_COLORS='cx=01;34' grep --color -E "$pattern" -A100 -B100)
    fi
}


# Create variants
v_create() {
    local arr=("$@")
    local stdin_data
    local variant
    local v_path

    # Check if STDIN has data
    if ! test -t 0; then
        stdin_data=$(</dev/stdin)
    fi

    for target in "${arr[@]}"; do
        for variant in "${variants[@]}"; do
            v_path="$CONFIG_DIR/$target/$variant"

            # Create either default or custom variant
            # TODO (?): Replace the "added" messages with a highlighted tree
            #           like in t_add().
            if [[ -z "$stdin_data" ]]; then
                if [[ ! -f "$v_path" ]]; then
                    touch "$v_path"
                    printf '%s\n' "$target: added \"$variant\""
                fi
            elif [[ ! -f "$v_path" ]]; then
                printf '%s\n' "$stdin_data" > "$v_path"
                printf '%s\n' "$target: added \"$variant\""
            fi
        done
    done
}


v_add() {
    local targets=()
    local variants=()
    local args

    (( "$#" == 0 )) && die "no templates specified"

    IFS=' ' read -r -a args <<< "$*"

    for arg in "${args[@]}"; do
        check_name "$arg"

        if grep -m 1 -q ^"$arg"$ <<< "$ALL_TARGETS"; then
            targets+=("$arg")
        else
            variants+=("$arg")
        fi
    done

    # If no targets are specified, create templates for all targets
    if [[ "${#targets}" -eq 0 ]]; then
        v_create ${ALL_TARGETS[*]}
    else
        v_create "${targets[@]}"
    fi
}


# Set variants for specific targets
v_setsome() {
    local v_path

    for variant in "${variants[@]}"; do
        for target in "${targets[@]}"; do
            v_path="$CONFIG_DIR/$target/$variant"

            # Skip targets that don't have the template or have empty ones
            [[ ! -f "$v_path" || ! -s "$v_path" ]] && continue

        done
    done
}


# Set a variant for all targets
v_setall() {
    local variant v v_path
    local target
    local match
    local t_path t_path2
    local body body2
    local begin offset end

    # Prevent multiple variants from being specified for all targets
    (( "$#" != 1 )) && die "multiple templates cannot be applied to all targets"

    for variant in "${variants[@]}"; do
        # ALL_TARGETS isn't an array, but a space-delimited string, so we use
        # [*] instead of [@].
        for target in ${ALL_TARGETS[*]}; do
            v_path="$CONFIG_DIR/$target/$variant"
            match=0

            # Skip targets that don't have the current variant or if their
            # variants are empty
            [[ ! -f "$v_path" || ! -s "$v_path" ]] && continue

            # Get target file name
            t_path="$(head -n 1 "$v_path")"

            # If target file doesn't exist, die
            [[ ! -f "$t_path" ]] && die "file \"$t_path\" does not exist\n" "$t_path"

            # Get variant body
            body="$(v_body "$v_path")"

            # See if the variant's body is being used
            if pcregrep -M -q "^${body}$" "$t_path"; then
                continue
            else
                # The variant is currently not being used, so check if another
                # variant is in use. If so, we can replace it. If not, then
                # there's nothing we can do so we'll consider this variant
                # invalid.
                for v in "$CONFIG_DIR"/"$target"/*; do
                    # Skip empty variants
                    [[ ! -s "$v" ]] && continue;

                    # Get variant config
                    t_path2="$(head -n 1 "$v")"

                    if [[ -f "$t_path2" ]]; then
                        # Get variant body
                        body2="$(v_body "$v")"

                        # Check if variant has a match
                        #
                        # Note that we use t_path instead of t_path2. That's
                        # because while this variant has a match, its target
                        # path may be invalid or different (though I don't
                        # really see that happening). So just to be safe, we
                        # use t_path.
                        if pcregrep -M -q "^${body2}$" "$t_path"; then
                            match=1
                            break
                        fi
                    fi
                done

                if [[ "$match" -eq 1 ]]; then
                    # There was another variant that has a match
                    begin="$(pcregrep -M -n "^${body2}$" "$t_path" | head -n 1 | cut -d: -f1)"
                    offset="$(wc -l <<< "$body2")"
                    end=$((begin + offset - 1))

                    sed -i "${begin},${end}d" "$t_path"
                    awk -i inplace -v a="$begin" -v b="$body" "NR==a{print b}1" "$t_path"
                else
                    # There was no match, so die
                    die "invalid \"$target\" variant: \"$variant\""
                fi
            fi
        done
    done
}


v_set() {
    local targets=()
    local variants=()
    local variant
    local name

    # Classify names as either targets or templates
    for name in "${@}"; do
        if grep -m 1 -q ^"$name"$ <<< "$ALL_TARGETS"; then
            targets+=("$name")
        else
            variants+=("$name")
        fi
    done

    if (( "${#targets}" == 0 )); then
        # No targets were specified, so set the variant for all
        v_setall "$@"
    else
        # Targets were specified, so set variants appropriately
        v_setsome
    fi
}


# Zero or more arguments were given but no options were specified, so either:
#
#  1. List templates of all/some targets.
#  2. Set templates for all/some targets.
#
# The decision process is like so:
#
#  * If no arguments are given, assume the user wants to see the templates for
#    all targets.
#
#  * If existing targets are specified, assume the user wants to see the
#    templates for those targets.
#
#  * If an existing template is specified, assume the user wants to set that
#    template for all targets.
#
#  * If existing templates and targets are specified, assume the user wants to
#    set some templates for some targets, and other templates for other targets.
v_start() {
    local name
    local nontargets

    if (( "$#" == 0 )); then
        # Nothing was given, so print all the things
        (cd "$CONFIG_DIR" && tree -L 1 --charset=utf-8 --noreport -- * | color_listing)
    else
        # Arguments were specified, so go through the decision process

        # Run names through some general checks
        for name in "${@}"; do
            check_name "$name"
        done

        # See if any of the names aren't target names; if so, collect them
        nontargets="$(cd "$CONFIG_DIR" && file "$@" | grep "cannot open" | cut -d: -f1)"

        if [[ -z "$nontargets" ]]; then
            # Only targets were specified, so list their templates
            (cd "$CONFIG_DIR" && tree -L 1 --charset=utf-8 --noreport -- "$@" | color_listing)
        else
            # Nontargets were found!

            # Clean up the name of nontargets a bit
            read -r -a nontargets <<< "$(tr '\n' ' ' <<< "$nontargets" | sed 's/[ ]*$//')"

            # Check if nontargets are variants
            for target in "${nontargets[@]}"; do
                [[ "$(find "$CONFIG_DIR"/* -name "$target" | wc -l)" == 0 ]] && die "unknown target or variant \"$target\""
            done

            # All nontargets are existing variants, so set them
            v_set "$@"
        fi
    fi
}

main() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        # Create configuration directory, if needed
        mkdir -p "$CONFIG_DIR"
    else
        # Get all variant and target names if configuration directory exists
        ALL_VARIANTS="$(find "$CONFIG_DIR" -maxdepth 2 -mindepth 2 ! -path "${CONFIG_DIR}/.git" | pathname)"
        ALL_TARGETS="$(find "$CONFIG_DIR" -maxdepth 1 -type d ! -path "$CONFIG_DIR" ! -path "${CONFIG_DIR}/.git" | pathname)"
    fi

    # Process command-line options/arguments
    while [[ "$1" ]]; do
        case $1 in
            "--version")
                printf '%s\n' "$PROG_NAME $VERSION"
                exit
            ;;
            "--help") usage ;;
            "--target" | "-t")
                shift
                t_add "$@"
                exit
            ;;
            "--variant" | "-v")
                shift
                v_add "$@"
                exit
            ;;
            "--edit" | "-e")
                EDIT=1
            ;;
            "--check" | "-c")
                shift
                v_check "$@"
                exit
            ;;
            "--list" | "-l")
                shift
                v_list "$@"
                exit
            ;;
            *)
                break
            ;;
        esac

        shift
    done

    v_start "$@"
}

main "$@"
