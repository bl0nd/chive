#!/usr/bin/env bash

PROG_NAME="chive"
VERSION="0.1.0"

XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-${HOME}/.config}
CONFIG_DIR="${XDG_CONFIG_HOME}/${PROG_NAME}"

# Speed up script by not using unicode.
LC_ALL=C
LANG=C

[[ -d "$CONFIG_DIR" ]] && {
    TEMPLATES="$(find "$CONFIG_DIR" -maxdepth 2 -mindepth 2 ! -path "${CONFIG_DIR}/.git" | awk -F/ '{print $NF}')"
    ALL_TARGETS="$(find "$CONFIG_DIR" -maxdepth 1 -type d ! -path "$CONFIG_DIR" ! -path "${CONFIG_DIR}/.git" | awk -F/ '{print $NF}')"
}

usage() {
    printf "%s\n" "\
usage: chive [--version] [--help] [--edit|-e] [--list|-l ] [--check|-c]
             [--add|-a TARGET ...] [--template|-t TARGET|TEMPLATE]
             [[TARGET ...] TEMPLATE] ...

Options:

   -a, -add TARGET ...          add targets
   -t, --template TEMPLATE ...  add templates
   -e, --edit TEMPLATE ...      edit templates
   -l, --list TEMPLATE ...      list templates
   -c, --check TEMPLATE ...     check templates

   --help                       show version information of $PROG_NAME
   --version                    show this help and exit
"
    exit 1
}

color_tree() {
    GREP_COLORS='sl=1;30:ms=01;34' grep --color '[^├─│└─]'
}

nltospace() {
    tr '\n' ' ' <<< "$1"
}

add_targets() {
    local targets
    local new_targets
    local pattern

    (( "$#" == 1 )) && {
        printf '%s\n' "error: no targets specified" 1>&2
        exit 1
    }

    shift
    IFS=' ' read -r -a targets <<< $*
    new_targets=()

    for target in "${targets[@]}"; do
        if [[ ! $target =~ ^[[:alnum:]](.*) ]]; then
            printf '%s\n' "error: target \"$target\" does not start with a letter/number." 1>&2
            exit 1
        elif [[ ! $target =~ ^([[:alnum:]]+[_-]*)*$ ]]; then
            printf '%s\n' "error: target \"$target\" does not contain only letters, numbers, \"_\", or \"-\"." 1>&2
            exit 1
        elif grep -m 1 -q ^"$target"$ <<< "$TEMPLATES"; then
            printf '%s\n' "error: \"${target}\" is a template name." 1>&2
            exit 1
        fi

        [[ ! -d "${CONFIG_DIR}"/"${target}" ]] && {
            mkdir -p "${CONFIG_DIR}/${target}"
            new_targets+=("$target")
        }
    done

    if (( "${#new_targets}" == 0 )); then
        (cd "$CONFIG_DIR" && ls -1 -d -- */ | sed 's/.$//' | color_tree)
    else
        pattern="$(sed 's/ /|/g' <<< "${new_targets[@]}" | xargs printf '^(%s)$')"
        (cd "$CONFIG_DIR" && ls -1 | GREP_COLORS='cx=01;34' grep --color -E "$pattern" -A100 -B100)
    fi
}

# This is the start of the main program:
#
#  * If there is an existing template specified, then we assume we want to set
#    templates.
#
#  * If there is an non-existing template specified, then we error out assuming
#    the user wanted to see templates of a particular target.
#
#  * If there is only targets, show templates for them.
#
#  * If there is nothing, show all templates.
go() {
    local failed_targets
    local failed_templates
    local error

    if (( "$#" == 0 )); then
        (cd "$CONFIG_DIR" && tree -L 1 --charset=utf-8 --noreport -- * | color_tree)
    else
        for target in "${@}"; do
            if [[ ! $target =~ ^[[:alnum:]](.*) ]]; then
                printf '%s\n' "error: target \"$target\" does not start with a letter/number." 1>&2
                exit 1
            elif [[ ! $target =~ ^([[:alnum:]]+[_-]*)*$ ]]; then
                printf '%s\n' "error: target \"$target\" does not contain only letters, numbers, \"_\", or \"-\"." 1>&2
                exit 1
            fi
        done

        failed_targets="$(cd "$CONFIG_DIR" && file "$@" | grep "cannot open" | cut -d: -f1)"

        if [[ -z "$failed_targets" ]]; then
            # only targets were specified, so list their templates
            (cd "$CONFIG_DIR" && tree -L 1 --charset=utf-8 --noreport -- "$@" | color_tree)
        else
            # some names failed, so check and see if they're template names
            failed_targets="$(nltospace "${failed_targets}" | sed 's/[ ]*$//')"
            failed_templates="$(cd "$CONFIG_DIR" && file -- */${failed_targets[*]} | grep "cannot open" | cut -d: -f1)"

            if [[ -n "$failed_templates" ]]; then
                # the names were not targets or templates so abort
                error="$(nltospace "$failed_templates" | sed 's/[ ]*$//' | xargs printf '"%s", ' | sed 's/\*\///')"
                printf 'error: unknown targets %s.\n' "${error%, }" 1>&2
                exit 1
            fi

            # there was a template name, so set target templates accordingly
            set_templates "$@"
        fi
    fi
}

set_templates() {
    local targets=()
    local templates=()
    local template
    local config

    for arg in "${@}"; do
        if grep -m 1 -q ^"$arg"$ <<< "$ALL_TARGETS"; then
            targets+=("$arg")
        else
            templates+=("$arg")
        fi
    done

    if (( "${#targets}" == 0 )); then
        # apply for all possible targets
        for template in "${templates[@]}"; do
            for target in ${ALL_TARGETS[*]}; do
                path="${CONFIG_DIR}/${target}/${template}"

                # skip targets that don't have the template
                [[ ! -f "$path" ]] && continue

                if [[ -s "$path" ]]; then
                    # process template
                    #
                    # The header should just be the filename.
                    config="$(head -n 1 "$path")"

                    if [[ -f "$config" ]]; then
                        # skip header, delete spaces in blank lines, delete leading/trailing blank lines
                        content="$(tail -n +2 "$path" | sed '/^[[:space:]]*$/d' | sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba')"

                        # grep contents in config
                        if pcregrep -M "^${content}$" "$config"; then
                            # continue as the template is already being used
                            continue
                        else
                            # check if any other templates match the current
                            # config. if so, use it to update to the new
                            # template
                            for t in "${CONFIG_DIR}"/"${target}"/*; do
                                [[ ! -s "$t" ]] && continue;

                                config="$(head -n 1 "$path")"

                                if [[ -f "$config" ]]; then
                                    o_content="$(tail -n +2 "$t" | sed '/^[[:space:]]*$/d' | sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba')"
                                    if pcregrep -M -q "^${o_content}$" "$config"; then
                                        match="$t"
                                        break
                                    fi
                                fi
                            done

                            if [[ -n "$match" ]]; then
                                # got a match, which means we can replace it
                                linenr="$(pcregrep -M -n "^${o_content}$" "$config" | head -n 1 | cut -d: -f1)"
                                offset="$(wc -l <<< "$o_content")"
                                endnr=$((linenr + offset - 1))  # "- 1" because we sed starts counting from 1
                                sed -i "${linenr},${endnr}d" "$config"
                                awk -i inplace -v a="$linenr" -v b="$content" "NR==a{print b}1" "$config"
                            else
                                # there was no other match, therefore the template is invalid
                                printf '%s\n' "error: invalid template \"$template\" for target \"$target\"" 1>&2
                                exit 1
                            fi

                        fi
                    else
                        printf 'error: file "%s" does not exist\n' "$config" >&2
                        exit 1
                    fi
                else
                    # skip empty template
                    continue
                fi
            done
        done

    else
        for template in "${templates[@]}"; do
            for target in "${targets[@]}"; do
                path="${CONFIG_DIR}/${target}/${template}"

                if [[ -s "$path" ]]; then
                    # Since the first line is skipped during updates, it doesn't really
                    # matter if it's commented or not.
                    #
                    # Note that the path will be taken as is, without tilde expansion.
                    header="$(head -n 1 "$path")"
                    #echo "$header"
                else
                    # Skip empty template
                    continue
                fi
            done
        done
    fi
}

add_templates() {
    local args
    local targets=()
    local templates=()
    local arr

    (( "$#" == 1 )) && {
        printf '%s\n' "error: no templates specified" 1>&2
        exit 1
    }

    shift
    IFS=' ' read -r -a args <<< "$*"

    for arg in "${args[@]}"; do
        if [[ ! $arg =~ ^[[:alnum:]](.*) ]]; then
            printf '%s\n' "error: template \"$arg\" does not start with a letter/number." 1>&2
            exit 1
        elif [[ ! $arg =~ ^([[:alnum:]]+[_-]*)*$ ]]; then
            printf '%s\n' "error: template \"$arg\" does not contain only letters, numbers, \"_\", or \"-\"." 1>&2
            exit 1
        elif grep -m 1 -q ^"$arg"$ <<< "$ALL_TARGETS"; then
            targets+=("$arg")
        else
            templates+=("$arg")
        fi
    done

    # if no targets are specified, create templates for all targets
    if [[ "${#targets}" -eq 0 ]]; then
        arr=($ALL_TARGETS)
        create_templates "${arr[@]}"
    else
        create_templates "${targets[@]}"
    fi
}

create_templates() {
    local ref
    local custom_template
    local path

    ref=("$@")

    if ! test -t 0; then
        custom_template=$(</dev/stdin)
    fi

    for target in "${ref[@]}"; do
        for template in "${templates[@]}"; do
            path="${CONFIG_DIR}/${target}/${template}"

            if test -t 0; then
                # if nothing is going to our stdin, create empty templates
                touch "$path"
            elif [[ ! -f "$path" ]]; then
                # use stdin as content for templates
                printf '%s\n' "$custom_template" > "$path"
            fi
        done
    done
}

main() {
    [[ ! -d "$CONFIG_DIR" ]] && {
        mkdir -p "${XDG_CONFIG_HOME}/${PROG_NAME}"
    }

    while [[ "$1" ]]; do
        case $1 in
            "--version")
                printf '%s\n' "$PROG_NAME $VERSION"
                exit 1
            ;;
            "--help") usage ;;

            "--add" | "-a")
                add_targets "$@"
                exit
            ;;

            "--template" | "-t")
                add_templates "$@"
                exit
            ;;

            "--edit" | "-e")
                EDIT=1
            ;;

            "--check" | "-c")
                check_templates "$@"
                exit
            ;;

            "--list" | "-l")
                list_templates "$@"
                exit
            ;;

            *)
                break
            ;;
        esac

        shift
    done

    go "$@"
}

main "$@"
